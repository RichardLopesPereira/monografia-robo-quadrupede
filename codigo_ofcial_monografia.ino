#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>
#include <WiFi.h>
#include <ArduinoOTA.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <string>
#include <esp_bt.h>  // Adicione no topo
#include <BLE2902.h>

Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40); // endereço padrão

// Configurações gerais
int estadoAtual = -10;     // -10 = Estado Inicial, 0 = Neutro, 1..4 = Frente, -1..-4 = Trás, 5..7 = Direita, -5..-7 = Esquerda
const int N_SERVOS = 12;   // Número de servos
const int N = 30;          // Número fixo de pontos da trajetória
int anguloBase = 90;       // Ângulo inicialmente utilizado como base para todos os servos
float angulosBase[N_SERVOS] = {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0};
float angulosAtuais[N_SERVOS] = {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0};
bool sistemaPronto = false;
bool pca_ok = false;       // Flag do estado do PCA9685

const char* ssid = "Nome_da_rede_de_Acesso"; //Nome da rede Wifi utilizada
const char* password = "****";  //Senha de acesso

String inputString = "";

// --- TELNET SERVER ---
WiFiServer telnetServer(23);
WiFiClient telnetClient;

// --- BLE SERVICE ---
BLEServer* pServer = nullptr;
BLECharacteristic* pCharacteristicRX;
BLECharacteristic* pCharacteristicTX;

bool deviceConnected = false;
std::string rxValue = "";

// --- UUIDs personalizados para conexão via BLE ---
#define SERVICE_UUID        "6E400001-B5A3-F393-E0A9-E50E24DCCA9E"
#define CHARACTERISTIC_UUID_RX "6E400002-B5A3-F393-E0A9-E50E24DCCA9E"
#define CHARACTERISTIC_UUID_TX "6E400003-B5A3-F393-E0A9-E50E24DCCA9E"

class MyServerCallbacks : public BLEServerCallbacks {
  void onConnect(BLEServer* pServer) override {
    deviceConnected = true;
    telnetClient.println("BLE conectado.");
  }

  void onDisconnect(BLEServer* pServer) override {
    deviceConnected = false;
    telnetClient.println("BLE desconectado.");
  }
};

class MyCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic* pCharacteristic) override { 
    std::string tempValue = pCharacteristic->getValue().c_str();

    if (tempValue.length() > 0) {
      rxValue = tempValue; 
      Serial.print("Comando recebido via BLE: ");
      telnetClient.println(rxValue.c_str());
    }
  }
};


// Trajetória gerada no MATLAB (q1...q12 em graus com 30 pontos) - Frente 1
float trajetoria_frente_1[N][N_SERVOS] = { //Perna 1 (esquerda traseira - q0, q1 e q2) e Perna 2 (diretira frente - q3, q4 e q5) vão para frente
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {89.6, 101.2, 121.7, 110.4, 101.2, 85.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {89.1, 102.5, 123.3, 110.8, 102.5, 86.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {88.7, 103.6, 124.8, 111.2, 103.6, 87.3, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {88.3, 104.8, 126.3, 111.6, 104.8, 87.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {87.8, 105.9, 127.8, 112.0, 105.8, 88.5, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {87.3, 106.9, 129.1, 112.4, 106.8, 89.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {86.9, 107.8, 130.4, 112.8, 107.7, 89.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {86.4, 108.6, 131.5, 113.2, 108.5, 89.7, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {85.9, 109.4, 132.6, 113.6, 109.2, 89.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {85.4, 110.0, 133.5, 113.9, 109.8, 89.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {84.9, 110.5, 134.4, 114.3, 110.3, 89.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {84.4, 110.9, 135.1, 114.7, 110.6, 89.7, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {83.9, 111.1, 135.6, 115.0, 110.8, 89.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {83.4, 111.2, 136.1, 115.4, 110.8, 89.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {82.9, 111.1, 136.4, 115.7, 110.7, 88.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {82.4, 110.9, 136.6, 116.0, 110.5, 87.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {81.8, 110.6, 136.7, 116.4, 110.1, 87.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {81.3, 110.1, 136.6, 116.7, 109.6, 86.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {80.7, 109.5, 136.4, 117.0, 109.0, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {80.2, 108.7, 136.1, 117.3, 108.2, 83.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {79.6, 107.9, 135.7, 117.7, 107.4, 82.5, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {79.0, 106.9, 135.1, 118.0, 106.4, 81.2, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {78.4, 105.9, 134.5, 118.3, 105.3, 79.7, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {77.8, 104.8, 133.7, 118.6, 104.1, 78.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {77.2, 103.6, 132.9, 118.9, 102.9, 76.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {76.6, 102.3, 132.0, 119.2, 101.6, 74.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {76.0, 101.0, 131.1, 119.4, 100.2, 72.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {75.4, 99.7, 130.1, 119.7, 98.8, 70.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {74.7, 98.4, 129.0, 120.0, 97.4, 68.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0}
};

// Trajetória gerada no MATLAB (q1...q12 em graus com 30 pontos) - Frente 2
float trajetoria_frente_2[N][N_SERVOS] = { //Perna 3 (direita frente - q6, q7 e q8) e Perna 4 (esquerda traseira - q9, q10 e q11) vão para frente, Pernas 1 e 2 retornam a posição inicial (empurram o robô)
  {74.7, 98.4, 129.0, 120.0, 97.4, 68.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {75.4, 97.2, 127.6, 119.7, 96.3, 68.3, 69.6, 61.2, 90.8, 90.4, 61.2, 76.7},
  {76.0, 96.1, 126.1, 119.4, 95.3, 67.7, 69.2, 62.5, 91.6, 90.9, 62.5, 78.3},
  {76.6, 95.0, 124.6, 119.2, 94.2, 67.1, 68.8, 63.6, 92.3, 91.3, 63.6, 79.8},
  {77.2, 93.9, 123.2, 118.9, 93.2, 66.5, 68.4, 64.8, 92.9, 91.7, 64.8, 81.3},
  {77.8, 92.9, 121.8, 118.6, 92.2, 65.9, 68.0, 65.8, 93.5, 92.2, 65.9, 82.8},
  {78.4, 92.0, 120.5, 118.3, 91.3, 65.4, 67.6, 66.8, 94.0, 92.7, 66.9, 84.1},
  {79.0, 91.2, 119.2, 118.0, 90.5, 65.0, 67.2, 67.7, 94.4, 93.1, 67.8, 85.4},
  {79.6, 90.4, 118.0, 117.7, 89.7, 64.7, 66.8, 68.5, 94.7, 93.6, 68.6, 86.5},
  {80.2, 89.7, 116.9, 117.3, 89.1, 64.4, 66.4, 69.2, 94.9, 94.1, 69.4, 87.6},
  {80.7, 89.1, 115.9, 117.0, 88.6, 64.3, 66.1, 69.8, 94.9, 94.6, 70.0, 88.5},
  {81.3, 88.7, 115.1, 116.7, 88.1, 64.3, 65.7, 70.3, 94.9, 95.1, 70.5, 89.4},
  {81.8, 88.4, 114.3, 116.4, 87.9, 64.4, 65.3, 70.6, 94.7, 95.6, 70.9, 90.1},
  {82.4, 88.2, 113.7, 116.0, 87.7, 64.7, 65.0, 70.8, 94.4, 96.1, 71.1, 90.6},
  {82.9, 88.1, 113.3, 115.7, 87.7, 65.2, 64.6, 70.8, 94.0, 96.6, 71.2, 91.1},
  {83.4, 88.1, 113.0, 115.4, 87.8, 65.7, 64.3, 70.7, 93.4, 97.1, 71.1, 91.4},
  {83.9, 88.3, 112.8, 115.0, 88.0, 66.5, 64.0, 70.5, 92.8, 97.6, 70.9, 91.6},
  {84.4, 88.6, 112.8, 114.7, 88.4, 67.3, 63.6, 70.1, 92.0, 98.2, 70.6, 91.7},
  {84.9, 89.1, 112.9, 114.3, 88.8, 68.4, 63.3, 69.6, 91.0, 98.7, 70.1, 91.6},
  {85.4, 89.6, 113.1, 113.9, 89.5, 69.5, 63.0, 69.0, 90.0, 99.3, 69.5, 91.4},
  {85.9, 90.3, 113.5, 113.6, 90.2, 70.7, 62.7, 68.2, 88.8, 99.8, 68.7, 91.1},
  {86.4, 91.1, 114.0, 113.2, 91.0, 72.1, 62.3, 67.4, 87.5, 100.4, 67.9, 90.7},
  {86.9, 92.0, 114.5, 112.8, 91.9, 73.5, 62.0, 66.4, 86.2, 101.0, 66.9, 90.1},
  {87.3, 93.0, 115.2, 112.4, 92.9, 75.1, 61.7, 65.3, 84.7, 101.6, 65.9, 89.5},
  {87.8, 94.0, 115.9, 112.0, 94.0, 76.7, 61.4, 64.1, 83.1, 102.2, 64.8, 88.7},
  {88.3, 95.1, 116.7, 111.6, 95.1, 78.3, 61.1, 62.9, 81.4, 102.8, 63.6, 87.9},
  {88.7, 96.3, 117.5, 111.2, 96.3, 80.0, 60.8, 61.6, 79.6, 103.4, 62.3, 87.0},
  {89.1, 97.5, 118.3, 110.8, 97.5, 81.6, 60.6, 60.2, 77.8, 104.0, 61.0, 86.1},
  {89.6, 98.8, 119.2, 110.4, 98.8, 83.3, 60.3, 58.8, 75.8, 104.6, 59.7, 85.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 60.0, 57.4, 73.9, 105.3, 58.4, 84.0}
};

// Trajetória gerada no MATLAB (q1...q6 em graus com 30 pontos) - Frente 3
float trajetoria_frente_3[N][N_SERVOS] = { //Perna 3 (direita frente - q6, q7 e q8) e Perna 4 (esquerda traseira - q9, q10 e q11)  voltam para a posição inicial (empurram o robô)
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 60.0, 57.4, 73.9, 105.3, 58.4, 84.0},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 60.3, 56.3, 73.3, 104.6, 57.2, 82.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 60.6, 55.3, 72.7, 104.0, 56.1, 81.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 60.8, 54.2, 72.1, 103.4, 55.0, 79.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 61.1, 53.2, 71.5, 102.8, 53.9, 78.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 61.4, 52.2, 70.9, 102.2, 52.9, 76.8},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 61.7, 51.3, 70.4, 101.6, 52.0, 75.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 62.0, 50.5, 70.0, 101.0, 51.2, 74.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 62.3, 49.7, 69.7, 100.4, 50.4, 73.0},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 62.7, 49.1, 69.4, 99.8, 49.7, 71.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 63.0, 48.6, 69.3, 99.3, 49.1, 70.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 63.3, 48.1, 69.3, 98.7, 48.7, 70.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 63.6, 47.9, 69.4, 98.2, 48.4, 69.3},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 64.0, 47.7, 69.7, 97.6, 48.2, 68.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 64.3, 47.7, 70.2, 97.1, 48.1, 68.3},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 64.6, 47.8, 70.7, 96.6, 48.1, 68.0},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 65.0, 48.0, 71.5, 96.1, 48.3, 67.8},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 65.3, 48.4, 72.3, 95.6, 48.6, 67.8},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 65.7, 48.8, 73.4, 95.1, 49.1, 67.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 66.1, 49.5, 74.5, 94.6, 49.6, 68.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 66.4, 50.2, 75.7, 94.1, 50.3, 68.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 66.8, 51.0, 77.1, 93.6, 51.1, 69.0},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 67.2, 51.9, 78.5, 93.1, 52.0, 69.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 67.6, 52.9, 80.1, 92.7, 53.0, 70.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 68.0, 54.0, 81.7, 92.2, 54.0, 70.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 68.4, 55.1, 83.3, 91.7, 55.1, 71.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 68.8, 56.3, 85.0, 91.3, 56.3, 72.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 69.2, 57.5, 86.6, 90.9, 57.5, 73.3},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 69.6, 58.8, 88.3, 90.4, 58.8, 74.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0}
};


// Trajetória gerada no MATLAB (q1...q12 em graus com 30 pontos) - Trás 1
float trajetoria_tras_1[N][N_SERVOS] = { //Perna 1 (esquerda traseira - q0, q1 e q2) e Perna 2 (diretira frente - q3, q4 e q5) vão para tras
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {90.4, 101.2, 120.8, 109.6, 101.2, 86.7, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {90.8, 102.5, 121.6, 109.1, 102.5, 88.3, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {91.2, 103.6, 122.3, 108.7, 103.6, 89.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {91.6, 104.8, 122.9, 108.3, 104.8, 91.3, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {92.0, 105.8, 123.5, 107.8, 105.9, 92.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {92.4, 106.8, 124.0, 107.3, 106.9, 94.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {92.8, 107.7, 124.4, 106.9, 107.8, 95.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {93.2, 108.5, 124.7, 106.4, 108.6, 96.5, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {93.6, 109.2, 124.9, 105.9, 109.4, 97.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {93.9, 109.8, 124.9, 105.4, 110.0, 98.5, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {94.3, 110.3, 124.9, 104.9, 110.5, 99.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {94.7, 110.6, 124.7, 104.4, 110.9, 100.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {95.0, 110.8, 124.4, 103.9, 111.1, 100.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {95.4, 110.8, 124.0, 103.4, 111.2, 101.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {95.7, 110.7, 123.4, 102.9, 111.1, 101.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {96.0, 110.5, 122.8, 102.4, 110.9, 101.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {96.4, 110.1, 122.0, 101.8, 110.6, 101.7, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {96.7, 109.6, 121.0, 101.3, 110.1, 101.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {97.0, 109.0, 120.0, 100.7, 109.5, 101.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {97.3, 108.2, 118.8, 100.2, 108.7, 101.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {97.7, 107.4, 117.5, 99.6, 107.9, 100.7, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {98.0, 106.4, 116.2, 99.0, 106.9, 100.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {98.3, 105.3, 114.7, 98.4, 105.9, 99.5, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {98.6, 104.1, 113.1, 97.8, 104.8, 98.7, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {98.9, 102.9, 111.4, 97.2, 103.6, 97.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {99.2, 101.6, 109.6, 96.6, 102.3, 97.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {99.4, 100.2, 107.8, 96.0, 101.0, 96.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {99.7, 98.8, 105.8, 95.4, 99.7, 95.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {100.0, 97.4, 103.9, 94.7, 98.4, 94.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0}
};

// Trajetória gerada no MATLAB (q1...q12 em graus com 30 pontos) - Trás 2
float trajetoria_tras_2[N][N_SERVOS] = { //Perna 3 (direita frente - q6, q7 e q8) e Perna 4 (esquerda traseira - q9, q10 e q11) vão para tras, Pernas 1 e 2 retornam a posição inicial (empurram o robô)
  {100.0, 97.4, 103.9, 94.7, 98.4, 94.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {99.7, 96.3, 103.3, 95.4, 97.2, 92.6, 70.4, 61.2, 91.7, 89.6, 61.9, 76.4},
  {99.4, 95.3, 102.7, 96.0, 96.1, 91.1, 70.9, 62.5, 93.3, 89.2, 63.7, 77.8},
  {99.2, 94.2, 102.1, 96.6, 95.0, 89.6, 71.3, 63.6, 94.8, 88.8, 65.5, 79.0},
  {98.9, 93.2, 101.5, 97.2, 93.9, 88.2, 71.7, 64.8, 96.3, 88.4, 67.2, 80.2},
  {98.6, 92.2, 100.9, 97.8, 92.9, 86.8, 72.2, 65.9, 97.8, 88.0, 68.8, 81.2},
  {98.3, 91.3, 100.4, 98.4, 92.0, 85.5, 72.7, 66.9, 99.1, 87.6, 70.3, 82.2},
  {98.0, 90.5, 100.0, 99.0, 91.2, 84.2, 73.1, 67.8, 100.4, 87.2, 71.7, 82.9},
  {97.7, 89.7, 99.7, 99.6, 90.4, 83.0, 73.6, 68.6, 101.5, 86.8, 72.9, 83.6},
  {97.3, 89.1, 99.4, 100.2, 89.7, 81.9, 74.1, 69.4, 102.6, 86.4, 74.0, 84.0},
  {97.0, 88.6, 99.3, 100.7, 89.1, 80.9, 74.6, 70.0, 103.5, 86.1, 74.9, 84.4},
  {96.7, 88.1, 99.3, 101.3, 88.7, 80.1, 75.1, 70.5, 104.4, 85.7, 75.6, 84.5},
  {96.4, 87.9, 99.4, 101.8, 88.4, 79.3, 75.6, 70.9, 105.1, 85.3, 76.1, 84.5},
  {96.0, 87.7, 99.7, 102.4, 88.2, 78.7, 76.1, 71.1, 105.6, 85.0, 76.4, 84.3},
  {95.7, 87.7, 100.2, 102.9, 88.1, 78.3, 76.6, 71.2, 106.1, 84.6, 76.5, 83.9},
  {95.4, 87.8, 100.7, 103.4, 88.1, 78.0, 77.1, 71.1, 106.4, 84.3, 76.4, 83.3},
  {95.0, 88.0, 101.5, 103.9, 88.3, 77.8, 77.6, 70.9, 106.6, 84.0, 76.1, 82.6},
  {94.7, 88.4, 102.3, 104.4, 88.6, 77.8, 78.2, 70.6, 106.7, 83.6, 75.6, 81.7},
  {94.3, 88.8, 103.4, 104.9, 89.1, 77.9, 78.7, 70.1, 106.6, 83.3, 74.9, 80.6},
  {93.9, 89.5, 104.5, 105.4, 89.6, 78.1, 79.3, 69.5, 106.4, 83.0, 74.0, 79.4},
  {93.6, 90.2, 105.7, 105.9, 90.3, 78.5, 79.8, 68.7, 106.1, 82.7, 72.9, 78.0},
  {93.2, 91.0, 107.1, 106.4, 91.1, 79.0, 80.4, 67.9, 105.7, 82.3, 71.7, 76.4},
  {92.8, 91.9, 108.5, 106.9, 92.0, 79.5, 81.0, 66.9, 105.1, 82.0, 70.3, 74.7},
  {92.4, 92.9, 110.1, 107.3, 93.0, 80.2, 81.6, 65.9, 104.5, 81.7, 68.7, 72.8},
  {92.0, 94.0, 111.7, 107.8, 94.0, 80.9, 82.2, 64.8, 103.7, 81.4, 67.1, 70.8},
  {91.6, 95.1, 113.3, 108.3, 95.1, 81.7, 82.8, 63.6, 102.9, 81.1, 65.3, 68.7},
  {91.2, 96.3, 115.0, 108.7, 96.3, 82.5, 83.4, 62.3, 102.0, 80.8, 63.4, 66.4},
  {90.8, 97.5, 116.6, 109.1, 97.5, 83.3, 84.0, 61.0, 101.1, 80.6, 61.5, 64.0},
  {90.4, 98.8, 118.3, 109.6, 98.8, 84.2, 84.6, 59.7, 100.1, 80.3, 59.4, 61.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 85.3, 58.4, 99.0, 80.0, 57.4, 58.9}
};

// Trajetória gerada no MATLAB (q1...q12 em graus com 30 pontos) - Trás 3
float trajetoria_tras_3[N][N_SERVOS] = { //Perna 3 (direita frente - q6, q7 e q8) e Perna 4 (esquerda traseira - q9, q10 e q11)  voltam para a posição inicial (empurram robô)
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 85.3, 58.4, 99.0, 80.0, 57.4, 58.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 84.6, 57.2, 97.6, 80.3, 55.7, 57.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 84.0, 56.1, 96.1, 80.6, 54.0, 56.3},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 83.4, 55.0, 94.6, 80.8, 52.3, 55.0},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 82.8, 53.9, 93.2, 81.1, 50.7, 53.8},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 82.2, 52.9, 91.8, 81.4, 49.1, 52.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 81.6, 52.0, 90.5, 81.7, 47.7, 51.4},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 81.0, 51.2, 89.2, 82.0, 46.3, 50.3},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 80.4, 50.4, 88.0, 82.3, 45.1, 49.4},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 79.8, 49.7, 86.9, 82.7, 44.0, 48.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 79.3, 49.1, 85.9, 83.0, 43.1, 48.0},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 78.7, 48.7, 85.1, 83.3, 42.4, 47.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 78.2, 48.4, 84.3, 83.6, 41.9, 47.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 77.6, 48.2, 83.7, 84.0, 41.6, 47.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 77.1, 48.1, 83.3, 84.3, 41.5, 48.0},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 76.6, 48.1, 83.0, 84.6, 41.6, 48.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 76.1, 48.3, 82.8, 85.0, 41.9, 49.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 75.6, 48.6, 82.8, 85.3, 42.5, 50.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 75.1, 49.1, 82.9, 85.7, 43.2, 51.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 74.6, 49.6, 83.1, 86.1, 44.1, 53.4},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 74.1, 50.3, 83.5, 86.4, 45.2, 55.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 73.6, 51.1, 84.0, 86.8, 46.5, 57.0},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 73.1, 52.0, 84.5, 87.2, 47.9, 59.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 72.7, 53.0, 85.2, 87.6, 49.4, 61.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 72.2, 54.0, 85.9, 88.0, 51.0, 63.4},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 71.7, 55.1, 86.7, 88.4, 52.7, 65.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 71.3, 56.3, 87.5, 88.8, 54.5, 68.0},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.9, 57.5, 88.3, 89.2, 56.3, 70.4},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.4, 58.8, 89.2, 89.6, 58.1, 72.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0}
};

// Trajetória gerada no MATLAB (q1...q12 em graus com 30 pontos) - Direita 1
float trajetoria_direita_1[N][N_SERVOS] = { //Perna 1 (esquerda traseira - q0, q1 e q2) e Perna 2 (diretira frente - q3, q4 e q5) vão para o sentido horário
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {90.8, 100.6, 120.6, 110.8, 100.6, 85.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {91.7, 101.2, 121.2, 111.7, 101.2, 86.2, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {92.5, 101.8, 121.8, 112.5, 101.8, 86.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {93.4, 102.4, 122.3, 113.4, 102.4, 87.3, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {94.2, 103.0, 122.8, 114.2, 103.0, 87.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {95.1, 103.5, 123.2, 115.1, 103.5, 88.2, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {95.9, 103.9, 123.6, 115.9, 103.9, 88.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {96.7, 104.4, 123.9, 116.7, 104.4, 88.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {97.6, 104.7, 124.1, 117.6, 104.7, 89.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {98.4, 105.1, 124.3, 118.4, 105.1, 89.3, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {99.2, 105.3, 124.4, 119.2, 105.3, 89.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {100.1, 105.5, 124.5, 120.1, 105.5, 89.5, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {100.9, 105.6, 124.4, 120.9, 105.6, 89.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {101.7, 105.7, 124.3, 121.7, 105.7, 89.3, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {102.5, 105.7, 124.1, 122.5, 105.7, 89.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {103.3, 105.6, 123.9, 123.3, 105.6, 88.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {104.1, 105.5, 123.5, 124.1, 105.5, 88.5, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {104.9, 105.3, 123.1, 124.9, 105.3, 88.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {105.7, 105.0, 122.6, 125.7, 105.0, 87.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {106.5, 104.7, 122.1, 126.5, 104.7, 87.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {107.2, 104.3, 121.5, 127.2, 104.3, 86.5, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {108.0, 103.8, 120.8, 128.0, 103.8, 85.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {108.8, 103.3, 120.0, 128.8, 103.3, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {109.5, 102.8, 119.2, 129.5, 102.8, 84.2, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {110.3, 102.2, 118.4, 130.3, 102.2, 83.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {111.0, 101.6, 117.5, 131.0, 101.6, 82.5, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {111.8, 101.0, 116.6, 131.8, 101.0, 81.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {112.5, 100.3, 115.6, 132.5, 100.3, 80.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {113.2, 99.6, 114.6, 133.2, 99.6, 79.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0}
};

// Trajetória gerada no MATLAB (q1...q6 em graus com 30 pontos) - Direita 2
float trajetoria_direita_2[N][N_SERVOS] = { //Perna 3 (direita frente - q6, q7 e q8) e Perna 4 (esquerda traseira - q9, q10 e q11) vão para o sentido horário, Pernas 1 e 2 retornam a posição inicial (empurram o robô)
  {113.2, 99.6, 114.6, 133.2, 99.6, 79.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {112.5, 99.1, 114.3, 132.5, 99.1, 79.3, 70.8, 60.6, 90.6, 90.8, 60.6, 75.6},
  {111.8, 98.5, 114.1, 131.8, 98.5, 79.1, 71.7, 61.2, 91.2, 91.7, 61.2, 76.2},
  {111.0, 97.9, 113.8, 131.0, 97.9, 78.8, 72.5, 61.8, 91.8, 92.5, 61.8, 76.8},
  {110.3, 97.4, 113.6, 130.3, 97.4, 78.6, 73.4, 62.4, 92.3, 93.4, 62.4, 77.3},
  {109.5, 96.9, 113.3, 129.5, 96.9, 78.3, 74.2, 63.0, 92.8, 94.2, 63.0, 77.8},
  {108.8, 96.4, 113.1, 128.8, 96.4, 78.1, 75.1, 63.5, 93.2, 95.1, 63.5, 78.2},
  {108.0, 95.9, 112.9, 128.0, 95.9, 77.9, 75.9, 63.9, 93.6, 95.9, 63.9, 78.6},
  {107.2, 95.5, 112.7, 127.2, 95.5, 77.7, 76.7, 64.4, 93.9, 96.7, 64.4, 78.9},
  {106.5, 95.2, 112.6, 126.5, 95.2, 77.6, 77.6, 64.7, 94.1, 97.6, 64.7, 79.1},
  {105.7, 94.9, 112.5, 125.7, 94.9, 77.5, 78.4, 65.1, 94.3, 98.4, 65.1, 79.3},
  {104.9, 94.6, 112.5, 124.9, 94.6, 77.5, 79.2, 65.3, 94.4, 99.2, 65.3, 79.4},
  {104.1, 94.4, 112.5, 124.1, 94.4, 77.5, 80.1, 65.5, 94.5, 100.1, 65.5, 79.5},
  {103.3, 94.3, 112.5, 123.3, 94.3, 77.5, 80.9, 65.6, 94.4, 100.9, 65.6, 79.4},
  {102.5, 94.2, 112.7, 122.5, 94.2, 77.7, 81.7, 65.7, 94.3, 101.7, 65.7, 79.3},
  {101.7, 94.2, 112.9, 121.7, 94.2, 77.9, 82.5, 65.7, 94.1, 102.5, 65.7, 79.1},
  {100.9, 94.3, 113.1, 120.9, 94.3, 78.1, 83.3, 65.6, 93.9, 103.3, 65.6, 78.9},
  {100.1, 94.5, 113.4, 120.1, 94.5, 78.4, 84.1, 65.5, 93.5, 104.1, 65.5, 78.5},
  {99.2, 94.7, 113.8, 119.2, 94.7, 78.8, 84.9, 65.3, 93.1, 104.9, 65.3, 78.1},
  {98.4, 94.9, 114.2, 118.4, 94.9, 79.2, 85.7, 65.0, 92.6, 105.7, 65.0, 77.6},
  {97.6, 95.2, 114.6, 117.6, 95.2, 79.6, 86.5, 64.7, 92.1, 106.5, 64.7, 77.1},
  {96.7, 95.6, 115.1, 116.7, 95.6, 80.1, 87.2, 64.3, 91.5, 107.2, 64.3, 76.5},
  {95.9, 96.1, 115.7, 115.9, 96.1, 80.7, 88.0, 63.8, 90.8, 108.0, 63.8, 75.8},
  {95.1, 96.5, 116.2, 115.1, 96.5, 81.2, 88.8, 63.3, 90.0, 108.8, 63.3, 75.0},
  {94.2, 97.0, 116.8, 114.2, 97.0, 81.8, 89.5, 62.8, 89.2, 109.5, 62.8, 74.2},
  {93.4, 97.6, 117.5, 113.4, 97.6, 82.5, 90.3, 62.2, 88.4, 110.3, 62.2, 73.4},
  {92.5, 98.2, 118.1, 112.5, 98.2, 83.1, 91.0, 61.6, 87.5, 111.0, 61.6, 72.5},
  {91.7, 98.8, 118.7, 111.7, 98.8, 83.7, 91.8, 61.0, 86.6, 111.8, 61.0, 71.6},
  {90.8, 99.4, 119.4, 110.8, 99.4, 84.4, 92.5, 60.3, 85.6, 112.5, 60.3, 70.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 93.2, 59.6, 84.6, 113.2, 59.6, 69.6}
};

// Trajetória gerada no MATLAB (q1...q6 em graus com 30 pontos) - Direita 3
float trajetoria_direita_3[N][N_SERVOS] = { //Perna 3 (direita frente - q6, q7 e q8) e Perna 4 (esquerda traseira - q9, q10 e q11)  voltam para a posição inicial (empurram robô)
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 93.2, 59.6, 84.6, 113.2, 59.6, 69.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 92.5, 59.1, 84.3, 112.5, 59.1, 69.3},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 91.8, 58.5, 84.1, 111.8, 58.5, 69.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 91.0, 57.9, 83.8, 111.0, 57.9, 68.8},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 90.3, 57.4, 83.6, 110.3, 57.4, 68.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 89.5, 56.9, 83.3, 109.5, 56.9, 68.3},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 88.8, 56.4, 83.1, 108.8, 56.4, 68.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 88.0, 55.9, 82.9, 108.0, 55.9, 67.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 87.2, 55.5, 82.7, 107.2, 55.5, 67.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 86.5, 55.2, 82.6, 106.5, 55.2, 67.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 85.7, 54.9, 82.5, 105.7, 54.9, 67.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 84.9, 54.6, 82.5, 104.9, 54.6, 67.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 84.1, 54.4, 82.5, 104.1, 54.4, 67.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 83.3, 54.3, 82.5, 103.3, 54.3, 67.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 82.5, 54.2, 82.7, 102.5, 54.2, 67.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 81.7, 54.2, 82.9, 101.7, 54.2, 67.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 80.9, 54.3, 83.1, 100.9, 54.3, 68.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 80.1, 54.5, 83.4, 100.1, 54.5, 68.4},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 79.2, 54.7, 83.8, 99.2, 54.7, 68.8},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 78.4, 54.9, 84.2, 98.4, 54.9, 69.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 77.6, 55.2, 84.6, 97.6, 55.2, 69.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 76.7, 55.6, 85.1, 96.7, 55.6, 70.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 75.9, 56.1, 85.7, 95.9, 56.1, 70.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 75.1, 56.5, 86.2, 95.1, 56.5, 71.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 74.2, 57.0, 86.8, 94.2, 57.0, 71.8},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 73.4, 57.6, 87.5, 93.4, 57.6, 72.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 72.5, 58.2, 88.1, 92.5, 58.2, 73.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 71.7, 58.8, 88.7, 91.7, 58.8, 73.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.8, 59.4, 89.4, 90.8, 59.4, 74.4},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0}
};


// Trajetória gerada no MATLAB (q1...q12 em graus com 30 pontos) - Esquerda 1
float trajetoria_esquerda_1[N][N_SERVOS] = { //Perna 1 (esquerda traseira - q0, q1 e q2) e Perna 2 (diretira frente - q3, q4 e q5) vão para o sentido anti-horário
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {88.7, 101.2, 120.8, 108.7, 101.2, 85.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {87.5, 102.5, 121.5, 107.5, 102.5, 86.5, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {86.3, 103.6, 122.2, 106.3, 103.6, 87.2, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {85.1, 104.8, 122.7, 105.1, 104.8, 87.7, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {83.9, 105.8, 123.2, 103.9, 105.8, 88.2, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {82.7, 106.8, 123.5, 102.7, 106.8, 88.5, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {81.6, 107.7, 123.8, 101.6, 107.7, 88.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {80.5, 108.5, 123.8, 100.5, 108.5, 88.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {79.4, 109.1, 123.8, 99.4, 109.1, 88.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {78.3, 109.6, 123.6, 98.3, 109.6, 88.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {77.3, 110.0, 123.3, 97.3, 110.0, 88.3, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {76.3, 110.3, 122.8, 96.3, 110.3, 87.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {75.3, 110.4, 122.2, 95.3, 110.4, 87.2, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {74.3, 110.3, 121.4, 94.3, 110.3, 86.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {73.3, 110.1, 120.4, 93.3, 110.1, 85.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {72.4, 109.8, 119.3, 92.4, 109.8, 84.3, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {71.5, 109.3, 118.0, 91.5, 109.3, 83.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {70.6, 108.6, 116.6, 90.6, 108.6, 81.6, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {69.7, 107.8, 115.0, 89.7, 107.8, 80.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {68.9, 106.9, 113.3, 88.9, 106.9, 78.3, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {68.1, 105.8, 111.4, 88.1, 105.8, 76.4, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {67.2, 104.6, 109.3, 87.2, 104.6, 74.3, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {66.5, 103.2, 107.1, 86.5, 103.2, 72.1, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {65.7, 101.8, 104.8, 85.7, 101.8, 69.8, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {64.9, 100.2, 102.3, 84.9, 100.2, 67.3, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {64.2, 98.6, 99.7, 84.2, 98.6, 64.7, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {63.5, 96.8, 96.9, 83.5, 96.8, 61.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {62.8, 94.9, 93.9, 82.8, 94.9, 58.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {62.1, 93.1, 90.9, 82.1, 93.1, 55.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
};

// Trajetória gerada no MATLAB (q1...q12 em graus com 30 pontos) - Esquerda 2
float trajetoria_esquerda_2[N][N_SERVOS] = { //Perna 3 (direita frente - q6, q7 e q8) e Perna 4 (esquerda traseira - q9, q10 e q11) vão para o sentido anti-horário, Pernas 1 e 2 retornam a posição inicial (empurram o robô)
  {62.1, 93.1, 90.9, 82.1, 93.1, 55.9, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0},
  {62.8, 92.3, 91.0, 82.8, 92.3, 56.0, 68.7, 61.2, 91.6, 88.7, 61.2, 76.6},
  {63.5, 91.6, 91.3, 83.5, 91.6, 56.3, 67.4, 62.5, 93.2, 87.4, 62.5, 78.2},
  {64.2, 91.0, 91.6, 84.2, 91.0, 56.6, 66.1, 63.6, 94.7, 86.1, 63.6, 79.7},
  {64.9, 90.3, 91.8, 84.9, 90.3, 56.8, 64.8, 64.8, 96.1, 84.8, 64.8, 81.1},
  {65.7, 89.6, 92.1, 85.7, 89.6, 57.1, 63.4, 65.9, 97.5, 83.4, 65.9, 82.5},
  {66.5, 89.0, 92.3, 86.5, 89.0, 57.3, 62.1, 66.9, 98.7, 82.1, 66.9, 83.7},
  {67.2, 88.5, 92.6, 87.2, 88.5, 57.6, 60.7, 67.9, 99.8, 80.7, 67.9, 84.8},
  {68.1, 88.0, 93.0, 88.1, 88.0, 58.0, 59.3, 68.7, 100.7, 79.3, 68.7, 85.7},
  {68.9, 87.5, 93.4, 88.9, 87.5, 58.4, 57.9, 69.5, 101.6, 77.9, 69.5, 86.6},
  {69.7, 87.2, 93.9, 89.7, 87.2, 58.9, 56.5, 70.1, 102.3, 76.5, 70.1, 87.3},
  {70.6, 87.0, 94.5, 90.6, 87.0, 59.5, 55.1, 70.6, 102.9, 75.1, 70.6, 87.9},
  {71.5, 86.9, 95.2, 91.5, 86.9, 60.2, 53.7, 71.0, 103.3, 73.7, 71.0, 88.3},
  {72.4, 86.9, 96.0, 92.4, 86.9, 61.0, 52.3, 71.3, 103.6, 72.3, 71.3, 88.6},
  {73.3, 87.0, 96.9, 93.3, 87.0, 61.9, 50.9, 71.4, 103.7, 70.9, 71.4, 88.7},
  {74.3, 87.2, 97.9, 94.3, 87.2, 62.9, 49.5, 71.4, 103.7, 69.5, 71.4, 88.7},
  {75.3, 87.6, 99.1, 95.3, 87.6, 64.1, 48.1, 71.3, 103.5, 68.1, 71.3, 88.5},
  {76.3, 88.0, 100.3, 96.3, 88.0, 65.3, 46.7, 71.0, 103.1, 66.7, 71.0, 88.1},
  {77.3, 88.6, 101.7, 97.3, 88.6, 66.7, 45.3, 70.6, 102.7, 65.3, 70.6, 87.7},
  {78.3, 89.3, 103.1, 98.3, 89.3, 68.1, 43.9, 70.1, 102.0, 63.9, 70.1, 87.0},
  {79.4, 90.0, 104.6, 99.4, 90.0, 69.6, 42.5, 69.5, 101.3, 62.5, 69.5, 86.3},
  {80.5, 90.9, 106.2, 100.5, 90.9, 71.2, 41.1, 68.7, 100.4, 61.1, 68.7, 85.4},
  {81.6, 91.9, 107.9, 101.6, 91.9, 72.9, 39.8, 67.9, 99.3, 59.8, 67.9, 84.3},
  {82.7, 92.9, 109.6, 102.7, 92.9, 74.6, 38.4, 66.9, 98.2, 58.4, 66.9, 83.2},
  {83.9, 94.0, 111.3, 103.9, 94.0, 76.3, 37.1, 65.9, 96.9, 57.1, 65.9, 81.9},
  {85.1, 95.1, 113.1, 105.1, 95.1, 78.1, 35.8, 64.8, 95.5, 55.8, 64.8, 80.5},
  {86.3, 96.3, 114.8, 106.3, 96.3, 79.8, 34.5, 63.7, 94.0, 54.5, 63.7, 79.0},
  {87.5, 97.5, 116.6, 107.5, 97.5, 81.6, 33.2, 62.5, 92.5, 53.2, 62.5, 77.5},
  {88.7, 98.8, 118.3, 108.7, 98.8, 83.3, 32.0, 61.2, 90.8, 52.0, 61.2, 75.8},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 30.7, 60.0, 89.1, 50.7, 60.0, 74.1}
};

// Trajetória gerada no MATLAB (q1...q12 em graus com 30 pontos) - Esquerda 3
float trajetoria_esquerda_3[N][N_SERVOS] = { //Perna 3 (direita frente - q6, q7 e q8) e Perna 4 (esquerda traseira - q9, q10 e q11)  voltam para a posição inicial (empurram robô)
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 30.7, 60.0, 89.1, 50.7, 60.0, 74.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 32.0, 58.8, 88.3, 52.0, 58.8, 73.3},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 33.2, 57.5, 87.5, 53.2, 57.5, 72.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 34.5, 56.3, 86.7, 54.5, 56.3, 71.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 35.8, 55.2, 85.9, 55.8, 55.2, 70.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 37.1, 54.1, 85.0, 57.1, 54.1, 70.0},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 38.4, 53.0, 84.3, 58.4, 53.0, 69.3},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 39.8, 52.1, 83.5, 59.8, 52.1, 68.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 41.1, 51.2, 82.8, 61.1, 51.2, 67.8},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 42.5, 50.4, 82.2, 62.5, 50.4, 67.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 43.9, 49.8, 81.7, 63.9, 49.8, 66.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 45.3, 49.2, 81.2, 65.3, 49.2, 66.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 46.7, 48.8, 80.9, 66.7, 48.8, 65.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 48.1, 48.5, 80.7, 68.1, 48.5, 65.7},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 49.5, 48.4, 80.6, 69.5, 48.4, 65.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 50.9, 48.4, 80.6, 70.9, 48.4, 65.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 52.3, 48.5, 80.8, 72.3, 48.5, 65.8},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 53.7, 48.8, 81.1, 73.7, 48.8, 66.1},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 55.1, 49.2, 81.4, 75.1, 49.2, 66.4},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 56.5, 49.8, 81.9, 76.5, 49.8, 66.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 57.9, 50.4, 82.5, 77.9, 50.4, 67.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 59.3, 51.2, 83.2, 79.3, 51.2, 68.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 60.7, 52.0, 83.9, 80.7, 52.0, 68.9},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 62.1, 53.0, 84.8, 82.1, 53.0, 69.8},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 63.4, 54.0, 85.6, 83.4, 54.0, 70.6},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 64.8, 55.2, 86.5, 84.8, 55.2, 71.5},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 66.1, 56.3, 87.4, 86.1, 56.3, 72.4},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 67.4, 57.5, 88.3, 87.4, 57.5, 73.3},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 68.7, 58.8, 89.2, 88.7, 58.8, 74.2},
  {90.0, 100.0, 120.0, 110.0, 100.0, 85.0, 70.0, 60.0, 90.0, 90.0, 60.0, 75.0}
};



// ---------------- Funções auxiliares ----------------

// Converte ângulo [0-180] → pulso [150-600]
int anguloParaPulso(int angulo) {
  int pulsoMin = 150;
  int pulsoMax = 600;
  if (angulo < 0) angulo = 0;
  if (angulo > 180) angulo = 180;
  return map(angulo, 0, 180, pulsoMin, pulsoMax);
}

// Centraliza ação de escrever servo + atualizar vetor
void setServoAngleRaw(int idx, int ang) {
  if (idx < 0 || idx >= N_SERVOS) return;

  // Definindo os limites de segurança
  const int ANGULO_MIN = 20;
  const int ANGULO_MAX = 160;
    
  ang = constrain(ang, ANGULO_MIN, ANGULO_MAX);

  angulosAtuais[idx] = ang;
  pwm.setPWM(idx, 0, anguloParaPulso(ang));
}

// Checa comunicação I²C
bool checkPCA() {
  Wire.beginTransmission(0x40);
  return (Wire.endTransmission() == 0);
}

// Envia resposta para Telnet e BLE 
void sendResponse(const String &msg, WiFiClient *client = nullptr) {
  String formattedMsg = msg;
  formattedMsg += "\n";

  // Telnet
  if (telnetClient && telnetClient.connected()) telnetClient.println(formattedMsg);

  // BLE notify
  if (deviceConnected && pCharacteristicTX) {
    pCharacteristicTX->setValue(formattedMsg.c_str());
    pCharacteristicTX->notify();
  }

  Serial.println(formattedMsg);
}

void stopAllServos() {
  for (int i = 0; i < N_SERVOS; i++) {
    pwm.setPWM(i, 0, 0);
  }
  Serial.println("⚠️ Falha I2C! Todos os servos parados.");
  sendResponse("Falha I2C! Todos os servos parados.");
}

// Imprimir matriz (utilizada para debug)
void imprimirLinhaMatriz(float linha[], int colunas) {
  String s = "[";
  for (int j = 0; j < colunas; j++) {
    s += String(linha[j], 1);
    if (j < colunas - 1) s += ", ";
  }
  s += "]";
  sendResponse(s);
}

// ---------------- Movimentação real das trajetórias ----------------

// Executa uma trajetória (linha a linha)
void executarTrajetoriaMovendo(float traj[N][N_SERVOS], unsigned long tempoTotalMs, bool invertida = false) {
  if (!pca_ok) {
    sendResponse("PCA9685 não conectado: abortando movimento.");
    return;
  }

  // tempo por linha
  unsigned long msPorLinha = tempoTotalMs / N; 
  if (msPorLinha == 0) msPorLinha = 1;

  if (!invertida) {
    for (int i = 0; i < N; i++) {
      
      //imprimirLinhaMatriz(traj[i], N_SERVOS);

      for (int j = 0; j < N_SERVOS; j++) {
        int destino = (int)(traj[i][j] + 0.5);
        
        if (destino != angulosAtuais[j]) {
          setServoAngleRaw(j, destino);
        }
      }

      // Mantém OTA e I2C responsivos
      unsigned long t0 = millis();
      while (millis() - t0 < msPorLinha) {
        ArduinoOTA.handle();
        if (!checkPCA()) {
          stopAllServos();
          sendResponse("Perda de comunicação I2C durante execução. Abortando.");
          return;
        }
        
        delay(2); //delay imprime mínimo trabalho no loop para não travar CPU
      }
    }
  } else {
    // Matriz Invertida: linha N-1 até 0
    for (int ii = N - 1; ii >= 0; ii--) {
      int i = ii;

      //imprimirLinhaMatriz(traj[i], N_SERVOS);

      for (int j = 0; j < N_SERVOS; j++) {
        int destino = (int)(traj[i][j] + 0.5);
        if (destino != angulosAtuais[j]) {
          setServoAngleRaw(j, destino);
        }
      }

      unsigned long t0 = millis();
      while (millis() - t0 < msPorLinha) {
        ArduinoOTA.handle();
        if (!checkPCA()) {
          stopAllServos();
          sendResponse("Perda de comunicação I2C durante execução (invertida). Abortando.");
          return;
        }
        delay(2);
      }
    }
  }
}

void executarTrajetoria(float traj[N][N_SERVOS]) {
  sendResponse("Iniciando execução da trajetória (3s)...");
  executarTrajetoriaMovendo(traj, 2000, false);
  sendResponse("Trajetória finalizada.");
}

// Executar trajetória invertida (de trás pra frente)
void executarTrajetoriaInvertida(float traj[N][N_SERVOS]) {
  sendResponse("Iniciando execução da trajetória invertida (3s)...");
  executarTrajetoriaMovendo(traj, 2000, true);
  sendResponse("Trajetória invertida finalizada.");
}

void posicaoNeutra() {
  if(estadoAtual == 0){
    sendResponse("Servos já estão posicionados na posição base");
  }else{
    sendResponse("Posicao base: Iniciando movimento seguro e lento para Base...");
    
    // --- PARÂMETROS GERAIS DE MOVIMENTO LENTO ---
    const unsigned long totalTime = 5000; // 5 segundos para suavizar o movimento
    const int steps = 30;
    unsigned long dt = totalTime / steps;
    if (dt == 0) dt = 1;

    int startAngles[N_SERVOS];

    for (int j = 0; j < N_SERVOS; j++) startAngles[j] = angulosAtuais[j]; 
    
    for (int s = 1; s <= steps; s++) {
        if (!checkPCA()) { stopAllServos(); return; }
        
        for (int j = 0; j < N_SERVOS; j++) {
            float novoF = startAngles[j] + (float)(angulosBase[j] - startAngles[j]) * ((float)s / steps);
            int novo = (int)(novoF + 0.5);
            if (novo != angulosAtuais[j])  setServoAngleRaw(j, novo);
        }
        ArduinoOTA.handle();
        delay(dt);
    }

    // Finalização
    estadoAtual = 0; 
    sendResponse("Base alcançada (angulosBase).");
  }
    
}

void inicializarServos() {
    sendResponse("Inicializando...");
    
    if (!checkPCA()) { stopAllServos(); sendResponse("Sem conexão com PCA..."); return; }
    
    for (int j = 0; j < N_SERVOS; j++) {
      setServoAngleRaw(j, angulosBase[j]);
      delay(1000);
    }
    ArduinoOTA.handle();

    // Finalização
    estadoAtual = 0; // Estado neutro/base alcançado
    sendResponse("Base alcancada (angulosBase).");
}

void interpretarComando(String comando) {
    comando.trim();
    sendResponse("Comando recebido: " + comando);

    if (comando == "start") {
        if (!pca_ok) {
            sendResponse("Erro: PCA9685 não conectado. Nao e possivel iniciar.");
            return;
        }
        if (estadoAtual != -10) {
            sendResponse("Sistema ja foi inicializado e está em execução.");
            return;
        }
        
        sistemaPronto = true; // Permite que comandos de movimento sejam processados
        inicializarServos(); 
        sendResponse("Sistema inicializado. Pronto para movimentacao.");
        return;
    }
    else if (comando == "fim") {// Move lentamente para a posição base (agora angulosBase)
        if (!sistemaPronto) {
            sendResponse("Sistema ja esta pausado.");
            return;
        }
        
        posicaoNeutra(); 
        sendResponse("Sistema pausado. Envie 'start' para reiniciar.");
        return;
    }
    else if (!sistemaPronto) {
        sendResponse("Sistema pausado. Envie 'start' para iniciar a movimentacao.");
        return;
    }
    else if (comando == "frente" && ((estadoAtual <= 3 && estadoAtual >= -3) || estadoAtual == 0)) {
        
        if (estadoAtual == 0) {// Se estava neutro → começa frente_1
            estadoAtual = 1;
            sendResponse("Executando trajetoria_frente_1");
            executarTrajetoria(trajetoria_frente_1);
            return;
        }
        
        if (estadoAtual > 0) {// Se estava indo pra frente → avança um estágio
            estadoAtual++;
            switch (estadoAtual) {
                case 2: sendResponse("Executando trajetoria_frente_2"); executarTrajetoria(trajetoria_frente_2); break;
                case 3: sendResponse("Executando trajetoria_frente_3"); executarTrajetoria(trajetoria_frente_3); estadoAtual = 0; break;
            }
            return;
        }
        
        if (estadoAtual < 0) {// Se estava indo pra trás → movimento inverso (volta um passo)
            switch (estadoAtual) {
                case -3: sendResponse("Executando trajetoria_tras_3 invertida"); executarTrajetoriaInvertida(trajetoria_tras_3); estadoAtual = -2; break;
                case -2: sendResponse("Executando trajetoria_tras_2 invertida"); executarTrajetoriaInvertida(trajetoria_tras_2); estadoAtual = -1; break;
                case -1: sendResponse("Executando trajetoria_tras_1 invertida"); executarTrajetoriaInvertida(trajetoria_tras_1); estadoAtual = 0; break; 
            }
            return;
        }
    }else if(comando == "frente" && ((estadoAtual >= 5 || estadoAtual <= -5) && estadoAtual != 0)){
      sendResponse("Não é possível andar para frente enquanto o movimento direita/esquerda estiver sendo feito");
    }
    else if (comando == "tras" && ((estadoAtual <= 3 && estadoAtual >= -3) || estadoAtual == 0)) {
        
        if (estadoAtual == 0) {// Se estava neutro → começa tras_1
            estadoAtual = -1;
            sendResponse("Executando trajetoria_tras_1");
            executarTrajetoria(trajetoria_tras_1);
            return;
        }

        if (estadoAtual < 0) { // Se estava indo pra trás → avança um estágio
            estadoAtual--;
            switch (estadoAtual) {
                case -2: sendResponse("Executando trajetoria_tras_2"); executarTrajetoria(trajetoria_tras_2); break;
                case -3: sendResponse("Executando trajetoria_tras_3"); executarTrajetoria(trajetoria_tras_3); estadoAtual = 0; break;
            }
            return;
        }
        
        if (estadoAtual > 0) {// Se estava indo pra frente → movimento inverso (volta um passo)
            switch (estadoAtual) {
                case 3: sendResponse("Executando trajetoria_frente_3 invertida"); executarTrajetoriaInvertida(trajetoria_frente_3); estadoAtual = 2; break;
                case 2: sendResponse("Executando trajetoria_frente_2 invertida"); executarTrajetoriaInvertida(trajetoria_frente_2); estadoAtual = 1; break;
                case 1: sendResponse("Executando trajetoria_frente_1 invertida"); executarTrajetoriaInvertida(trajetoria_frente_1); estadoAtual = 0; break; 
            }
            return;
        }
    }else if(comando == "tras" && ((estadoAtual >= 5 || estadoAtual <= -5) && estadoAtual != 0)){
      sendResponse("Não é possível andar para trás enquanto o movimento direita/esquerda estiver sendo feito");
    }
    else if (comando == "direita" && (estadoAtual >= 5 || estadoAtual <= -5 || estadoAtual == 0)) {
        
        if (estadoAtual == 0) {// Se estava neutro → começa direita_1
            estadoAtual = 5;
            sendResponse("Executando trajetoria_direita_1");
            executarTrajetoria(trajetoria_direita_1);
            return;
        }
        
        if (estadoAtual > 4) {// Se estava indo pra direita → avança um estágio
            estadoAtual++;

            switch (estadoAtual) {
                case 6: sendResponse("Executando trajetoria_direita_2"); executarTrajetoria(trajetoria_direita_2); break;
                case 7: sendResponse("Executando trajetoria_direita_3"); executarTrajetoria(trajetoria_direita_3); estadoAtual = 0; break;
            }
            return;
        }
        
        if (estadoAtual < -4) {// Se estava indo pra esquerda → movimento inverso (volta um passo)
            switch (estadoAtual) {
                case -7: sendResponse("Executando trajetoria_esquerda_3 invertida"); executarTrajetoriaInvertida(trajetoria_esquerda_3); estadoAtual = -6; break;
                case -6: sendResponse("Executando trajetoria_esquerda_2 invertida"); executarTrajetoriaInvertida(trajetoria_esquerda_2); estadoAtual = -5; break;
                case -5: sendResponse("Executando trajetoria_esquerda_1 invertida"); executarTrajetoriaInvertida(trajetoria_esquerda_1); estadoAtual = 0; break; 
            }
            return;
        }
    }else if(comando == "direita" && (estadoAtual < 5 && estadoAtual > -5 && estadoAtual != 0)){
      sendResponse("Não é possível andar para direita enquanto o movimento direita/esquerda estiver sendo feito");
    }
    else if (comando == "esquerda" && (estadoAtual >= 5 || estadoAtual <= -5 || estadoAtual == 0)) {
        
        if (estadoAtual == 0) {// Se estava neutro → começa esquerda_1
            estadoAtual = -5;
            sendResponse("Executando trajetoria_esquerda_1");
            executarTrajetoria(trajetoria_esquerda_1);
            return;
        }
        
        if (estadoAtual < -4) {// Se estava indo pra esquerda → avança um estágio
            estadoAtual--;

            switch (estadoAtual) {
                case -6: sendResponse("Executando trajetoria_esquerda_2"); executarTrajetoria(trajetoria_esquerda_2); break;
                case -7: sendResponse("Executando trajetoria_esquerda_3"); executarTrajetoria(trajetoria_esquerda_3); estadoAtual = 0; break;
            }
            return;
        }
        
        if (estadoAtual > 4) {// Se estava indo pra direita → movimento inverso (volta um passo)
            switch (estadoAtual) {
                case 7: sendResponse("Executando trajetoria_direita_3 invertida"); executarTrajetoriaInvertida(trajetoria_direita_3); estadoAtual = 6; break;
                case 6: sendResponse("Executando trajetoria_direita_2 invertida"); executarTrajetoriaInvertida(trajetoria_direita_2); estadoAtual = 5; break;
                case 5: sendResponse("Executando trajetoria_direita_1 invertida"); executarTrajetoriaInvertida(trajetoria_direita_1); estadoAtual = 0; break; 
            }
            return;
        }
    }else if(comando == "esquerda" &&  (estadoAtual < 5 && estadoAtual > -5 && estadoAtual != 0)){
      sendResponse("Não é possível andar para esquerda enquanto o movimento direita/esquerda estiver sendo feito");
    }
}

// ---------------- Setup ----------------
void setup() {
  Serial.begin(9600);
  Wire.begin(21, 22);  // ESP32: SDA=21, SCL=22
  pwm.begin();
  pwm.setPWMFreq(60);

  pca_ok = checkPCA();
  if (!pca_ok){
    stopAllServos();
    telnetClient.println("PCA9685 não detectado no endereço 0x40.");
  }
    
  telnetClient.println("Booting...");

  telnetClient.println("Iniciando OTA...");

  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);

  telnetClient.println("Conectando Wi-Fi");

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    telnetClient.print(".");
  }
  telnetClient.println("WiFi conectado. Endereço IP: ");
  telnetClient.println(WiFi.localIP());

  // Inicialização do OTA
  ArduinoOTA.setHostname("ESP32-ROBO");
  ArduinoOTA
    .onStart([]() {
      telnetClient.println("Iniciando upload OTA...");
    })
    .onEnd([]() {
      telnetClient.println("\nUpload concluído!");
    })
    .onProgress([](unsigned int progress, unsigned int total) {
      telnetClient.printf("Progresso: %u%%\r", (progress / (total / 100)));
    })
    .onError([](ota_error_t error) {
      telnetClient.printf("Erro [%u]: ", error);
      if (error == OTA_AUTH_ERROR) telnetClient.println("Falha na autenticação");
      else if (error == OTA_BEGIN_ERROR) telnetClient.println("Falha no início");
      else if (error == OTA_CONNECT_ERROR) telnetClient.println("Falha de conexão");
      else if (error == OTA_RECEIVE_ERROR) telnetClient.println("Falha no recebimento");
      else if (error == OTA_END_ERROR) telnetClient.println("Falha ao finalizar");
    });

  ArduinoOTA.begin();
  telnetClient.println("OTA pronto. Aguardando upload...");

  telnetClient.println("Ready");
  telnetClient.print("IP address: ");
  telnetClient.println(WiFi.localIP());

  // --- Telnet ---
  telnetServer.begin();
  telnetServer.setNoDelay(true);
  telnetClient.println("Telnet server started on port 23");

  // --- BLE CONFIGURAÇÃO ---
  esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT);
  BLEDevice::deinit(true);  // força reset da pilha BLE
  delay(100);
  BLEDevice::init("ESP32_Richard_BLE");
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());

  BLEService* pService = pServer->createService(SERVICE_UUID);
  pCharacteristicTX = pService->createCharacteristic(
                        CHARACTERISTIC_UUID_TX,
                        BLECharacteristic::PROPERTY_NOTIFY
                      );

  // Adiciona o descritor CCCD para permitir notificações
  pCharacteristicTX->addDescriptor(new BLE2902());

  pCharacteristicRX = pService->createCharacteristic(
                        CHARACTERISTIC_UUID_RX,
                        BLECharacteristic::PROPERTY_WRITE
                      );

  pCharacteristicRX->setCallbacks(new MyCallbacks());
  pService->start();

  BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(true);
  pAdvertising->setMinPreferred(0x06);
  pAdvertising->setMinPreferred(0x12);
  pAdvertising->start();
  telnetClient.println("BLE Advertising iniciado!");
  telnetClient.println("BLE iniciado. Agora pode conectar via app BLE (ex: nRF Connect)");

  delay(300);

  sistemaPronto = true;
  telnetClient.println("Para iniciar o sistema digite 'start'. Após isso, comandos disponíveis:");
  telnetClient.println("Digite 'frente' ou 'tras' para executar trajetória.");
  telnetClient.println("Digite 'fim' para retornar ao neutro.");
  

}

// ---------------- Loop ----------------
void loop() {
  ArduinoOTA.handle();
  // Checagem de segurança contínua
  if (!checkPCA()) {
    stopAllServos();
    // Tenta reconectar, não bloqueante
    static unsigned long lastAttempt = 0;
    if (millis() - lastAttempt > 1000) {
      lastAttempt = millis();
      Serial.println("Aguardando reconexão do PCA9685...");
      pca_ok = checkPCA();
      if (pca_ok) {
        sendResponse("✅ PCA9685 reconectado.");
      }
    }
  } else {

    // --- TELNET ---
    if (!telnetClient || !telnetClient.connected()) {
      WiFiClient client = telnetServer.available();
      if (client) {
        telnetClient = client;
        telnetClient.setNoDelay(true);
        telnetClient.println("Cliente Telnet conectado");
      }
    } else {
      while (telnetClient.available()) {
        char c = telnetClient.read();
        if (c == '\n' || c == '\r') {
          if (inputString.length() > 0) {
            sendResponse("Comando recebido via Telnet: " + inputString, &telnetClient);
            interpretarComando(inputString);
            inputString = "";
          }
        } else inputString += c;
      }
    }

    // --- BLE ---
    if (rxValue.length() > 0) {
      String cmd = String(rxValue.c_str());
      interpretarComando(cmd);
      rxValue = "";
    }

    delay(10);
  }
}

